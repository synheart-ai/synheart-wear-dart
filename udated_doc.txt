# SDK Integration Guide: Real-time Health Data

This guide provides step-by-step instructions for building a Synheart-compatible SDK that leverages **Wear Service** and **RAMEN Service**.

## 1. Project Setup

### Proto Generation
Generate the gRPC stubs from the `ramen.proto` and `wear.proto` files located in the `api` module of the monorepo.

```bash
# Example for Kotlin/Android
protoc --kotlin_out=./src --grpc-kotlin_out=./src -I ../api/proto ../api/proto/ramen/ramen.proto
```

## 2. Authentication Flow

Always include authentication in gRPC metadata.

```kotlin
val headers = Metadata()
headers.put(Metadata.Key.of("x-app-id", Metadata.ASCII_STRING_MARSHALLER), "YOUR_APP_ID")
headers.put(Metadata.Key.of("x-api-key", Metadata.ASCII_STRING_MARSHALLER), "YOUR_API_KEY")

// Or using User Token
// headers.put(Metadata.Key.of("authorization", Metadata.ASCII_STRING_MARSHALLER), "Bearer $token")
```

## 3. Persistent Connection (RAMEN)

The core characteristic of the Synheart SDK is the **persistent bidirectional stream**.

### The Subscription Loop

1.  **Open Stream**: Call `ramenService.subscribe()`.
2.  **Initial Message**: Send a `SubscribeRequest`.
    *   `last_seq`: Read this from local storage. If this is the first time, set to `0`.
    *   `device_id`: Use a unique hardware ID (IDFV on iOS, Android ID).
3.  **Read Events**: 
    - When an `EventEnvelope` arrives, parse the `payload` (JSON).
    - **Crucial**: After successful processing, send an `Ack(seq = event.seq)` back through the same stream.
    - Save the `seq` to local storage immediately.

```kotlin
// Pseudocode for Event Handling
stream.collect { serverMessage ->
    when (serverMessage.message) {
        is Event -> {
            val event = serverMessage.event
            notifyApp(event)
            stream.send(Ack(seq = event.seq))
            localStorage.saveLastSeq(event.seq)
        }
        is HeartbeatAck -> {
            updateLatency(serverMessage.heartbeatAck.rttMs)
        }
    }
}
```

### Heartbeat Responsibility
The SDK is responsible for keeping the connection alive.
- **Action**: Every 30 seconds, send a `Heartbeat(timestamp = now())`.
- **timeout**: If a `HeartbeatAck` is not received after 2 attempts, force-close the connection and reconnect.

## 4. Manual Data Fetching (Wear Service)

If a user wants to view historical data, use the REST API.

**URL**: `https://api.synheart.ai/wear/v1/{vendor}/data/{userId}/...`

| Feature | Service | Protocol | Key Benefit |
|---------|---------|----------|-------------|
| Real-time Alerts | RAMEN | gRPC | Low Latency |
| Daily Summaries | RAMEN | gRPC | Automatic Sync |
| Historical Charts| Wear | REST/HTTP| Bulk Data |
| Backfill | Wear | REST/HTTP| Long History |

## 5. Best Practices

1.  **Foreground/Background**:
    - **Background**: Close the gRPC stream to save battery. The server will keep events in the outbox.
    - **Foreground**: Re-open the stream. RAMEN will automatically replay missed events using your `last_seq`.
2.  **Idempotency**: Always process events based on their `event_id`. Occasionally, replayed events might have been already processed but not acknowledged.
3.  **Backoff**: Use exponential backoff for reconnections (1s, 2s, 4s, 8s...) to avoid hammering the load balancer.

---
Need help? Reach out in the `#dev-support` Slack channel.