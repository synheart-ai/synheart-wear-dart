import 'dart:async';

import 'package:flutter/services.dart';
import 'package:synheart_wear/src/adapters/ble_hrm_models.dart';

/// Platform bridge for BLE Heart Rate Monitor operations.
///
/// Uses Flutter platform channels to communicate with native BLE code:
/// - MethodChannel for scan/connect/disconnect/isConnected
/// - EventChannel for streaming heart rate samples
class BleHrmProvider {
  BleHrmProvider()
      : _method = const MethodChannel('synheart_wear/ble_hrm/method'),
        _events = const EventChannel('synheart_wear/ble_hrm/events');

  final MethodChannel _method;
  final EventChannel _events;

  StreamSubscription<dynamic>? _eventSubscription;
  final StreamController<HeartRateSample> _hrController =
      StreamController<HeartRateSample>.broadcast();

  bool _listening = false;

  /// Scan for nearby BLE heart rate monitor devices.
  ///
  /// [timeoutMs] — scan duration in milliseconds (default 5000).
  /// [namePrefix] — optional filter by device name prefix.
  Future<List<BleHrmDevice>> scan({
    int timeoutMs = 5000,
    String? namePrefix,
  }) async {
    try {
      final result = await _method.invokeMethod<List<dynamic>>('scan', {
        'timeoutMs': timeoutMs,
        if (namePrefix != null) 'namePrefix': namePrefix,
      });
      if (result == null) return [];
      return result
          .cast<Map<dynamic, dynamic>>()
          .map(BleHrmDevice.fromMap)
          .toList();
    } on PlatformException catch (e) {
      throw _mapError(e);
    }
  }

  /// Connect to a BLE heart rate monitor and start receiving samples.
  ///
  /// [deviceId] — the device to connect to (from [scan] results).
  /// [sessionId] — optional session ID to tag samples with.
  /// [enableBattery] — whether to request battery level notifications.
  Future<void> connect({
    required String deviceId,
    String? sessionId,
    bool enableBattery = false,
  }) async {
    try {
      await _method.invokeMethod<void>('connect', {
        'deviceId': deviceId,
        'sessionId': sessionId,
        'enableBattery': enableBattery,
      });
      _ensureListening();
    } on PlatformException catch (e) {
      throw _mapError(e);
    }
  }

  /// Disconnect from the current BLE heart rate monitor.
  Future<void> disconnect() async {
    try {
      await _method.invokeMethod<void>('disconnect');
    } on PlatformException catch (e) {
      throw _mapError(e);
    }
  }

  /// Check if a BLE heart rate monitor is currently connected.
  Future<bool> isConnected() async {
    try {
      final result = await _method.invokeMethod<bool>('isConnected');
      return result ?? false;
    } on PlatformException catch (e) {
      throw _mapError(e);
    }
  }

  /// Stream of heart rate samples from the connected device.
  Stream<HeartRateSample> get onHeartRate => _hrController.stream;

  /// Start listening to the event channel if not already.
  void _ensureListening() {
    if (_listening) return;
    _listening = true;

    _eventSubscription = _events.receiveBroadcastStream().listen(
      (dynamic event) {
        if (event is Map) {
          final sample = HeartRateSample.fromMap(event);
          _hrController.add(sample);
        }
      },
      onError: (Object error) {
        if (error is PlatformException) {
          _hrController.addError(_mapError(error));
        } else {
          _hrController.addError(error);
        }
      },
    );
  }

  /// Release resources.
  void dispose() {
    _eventSubscription?.cancel();
    _eventSubscription = null;
    _listening = false;
    _hrController.close();
  }

  /// Map a [PlatformException] to a typed [BleHrmError].
  static BleHrmError _mapError(PlatformException e) {
    final code = switch (e.code) {
      'PERMISSION_DENIED' => BleHrmErrorCode.permissionDenied,
      'BLUETOOTH_OFF' => BleHrmErrorCode.bluetoothOff,
      'DEVICE_NOT_FOUND' => BleHrmErrorCode.deviceNotFound,
      'SUBSCRIBE_FAILED' => BleHrmErrorCode.subscribeFailed,
      'DISCONNECTED' => BleHrmErrorCode.disconnected,
      _ => BleHrmErrorCode.subscribeFailed,
    };
    return BleHrmError(code, e.message);
  }
}
